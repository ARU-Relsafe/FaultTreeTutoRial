[
["index.html", "Tutorial: FaultTree Package Welcome To FaultTree Tutorial", " Tutorial: FaultTree Package David J. Silkworth Welcome To FaultTree Tutorial This is the online version for the R FaultTree package tutorial available at openreliability.org. Pull requests and general comments are welcome. Author David J.Silkworth bookdown editing by Carles CG References The package can be found in GitHub. The original tutorial can be found at openreliability.org R is free software and comes with ABSOLUTELY NO WARRANTY. You are welcome to redistribute it under the terms of the GNU General Public License versions 2 or 3. For more information about these matters see http://www.gnu.org/licenses/. "],
["intro.html", "Chapter 1 Introduction 1.1 Getting started with FaultTree on R 1.2 Load FaulTree package", " Chapter 1 Introduction 1.1 Getting started with FaultTree on R This introduction will cover installation of R and the FaultTree package. R has been selected as the container environment for this open source Fault Tree Analysis software. R is an excellent prototyping environment, although it is not known for its user friendliness. This introduction will hopefully get tentative users off to a running start. Although R is multi-platform environment, this introduction will be made from a Windows user perspective. A Windows installer for the R environment is available for free download starting at https://www.r-project.org/ Select the download link, then choose a mirror (the first selection always works for me). Here you will view the download links for the three supported operating systems. It does not matter which version of Windows you are using. On a 32-bit installation you will get a 32-bit R system. On a 64-bit system you will get both the 32-bit and the 64-bit installation. Don’t worry it doesn’t really matter which one you use. We are only concerned with a base installation, click on the ‘install R for the first time’ link. It is fine to install with default conditions, however, this creates an MDI application where multiple instances can run in a single container. I find this uncomfortable and prefer the SDI format. Want to try again? Uninstall through the ControlPanel and re-run the installer. This time select a ‘custom installation’, which will give you a chance to install the SDI format. All the other defaults are fine. I should mention here that there is a further developer environment that some prefer called R Studio. This application gives an unabashed look and feel of MatLab to R. This is also available as a free download at https://www.rstudio.com/products/RStudio/ The remainder of this introduction will refer to the simplest R SDI installation. Really we don’t need to know much about the R programming language to use FaultTree. Most people find R to have a very steep learning curve, largely due to the stark terminal window that it opens up to. This introduction hopes to guide any first-time user to success. FaultTree is a package that must be loaded into R. The package is hosted at R-Forge : https://r-forge.r-project.org/ From that location navigation would be required by search of Project – ftree. From that location one must select the R Packages link just below the Fault Tree and Event Tree Analysis title button. Or for those in a rush, just load the following URL: https://r-forge.r-project.org/R/?group_id=2125 Yes, there is more than one package addressed here. We of course want FaultTree. There are two ways to load this package into your R installation I will walk through both. You can download the .zip file next to the Windows logo. But, do not unzip this as one might expect! Rather, we will open this using the R environment. Run an R instance – as administrator. This is usually accomplished by right clicking on the icon and selecting ‘Run as administrator’. I prefer this since only the administrator can load the package into the main R installation, rather than a separate user library. This is a bit of Linux legacy, but we now have users separate from administrator on Windows since Windows 7. Now, in the R Console select the Packages menu item. Then at the bottom of the dropdown menu select ‘Install package(s) from local zip files…’ Navigate to the location of the downloaded zip from R-forge and open it in R. You should see the following confirmation in the R Console: utils:::menuInstallLocal() # package ‘FaultTree’ successfully unpacked and MD5 sums checked Before continuing, I will mention perhaps an easier method of installation. R-forge provides an automated download and installation command line just underneath the Linux and Windows icons with (.tar.gz) and (.zip) respectively. Generally from the latest version of R (that’s what you have if you just downloaded for the first time) -as administrator - you should be able to just copy and paste the installation command: install.packages(“FaultTree”, repos=“http://R-Forge.R-project.org”) directly into the R Console. install.packages(&quot;FaultTree&quot;, repos=&quot;http://R-Forge.R-project.org&quot;) I just tried this with R version 3.3.1 and it did not work because R-Forge had not gotten around to updating the package build (at version 0.0.9) since R version 3.3.0 . So I got a failure message for this reason. However the earlier zip method works on all versions. Alternatively install from GitHub repository: devtools::install_github(&quot;CarlesCG/FaultTree&quot;) This installation operation is only performed once per version of the package. From this point we can use the FaultTree package on each session of R by just mounting the library, which has already been installed in your local file system. This is done by the simple command line directly into the R Console: 1.2 Load FaulTree package library(FaultTree) This command line only needs to be executed once each R session. That is you can simply open either the 32-bit or the 64-bit R icon by double click and enter this library entry. You may get a warning about the package built under a different R version, but this is only a warning of no significance. There is no harm in making the library call repeatedly, it is just not necessary. Many example scripts will include the library line, perhaps as just a reminder. To conclude this introduction we will run an example. An alternate location for posting of this package source is located on Github: https://github.com/jto888/FaultTree A README.md file opens below the repository. Simply copy and paste the presented script (repeated below) into the R Console. tree1&lt;-ftree.make(type=&quot;priority&quot;,reversible_cond=TRUE, name=&quot;Site power loss&quot;) tree1&lt;-addLogic(tree1, at=1, type=&quot;or&quot;, name=&quot;neither emergency&quot;, name2=&quot;generator operable&quot;) tree1&lt;-addLogic(tree1, at=2, type=&quot;and&quot;, name=&quot;Independent failure&quot;, name2=&quot;of generators&quot;) tree1&lt;-addLatent(tree1, at=3, mttf=5,mttr=12/8760,inspect=1/26, name=&quot;e-gen set fails&quot;) tree1&lt;-addLatent(tree1, at=3, mttf=5,mttr=12/8760,inspect=1/26, name=&quot;e-gen set fails&quot;) tree1&lt;-addLogic(tree1, at=2, type=&quot;inhibit&quot;, name=&quot;Common cause&quot;, name2=&quot;failure of generators&quot;) tree1&lt;-addProbability(tree1, at=6, prob=.05, name=&quot;Common cause&quot;, name2=&quot;beta factor&quot;) tree1&lt;-addLatent(tree1, at=6, mttf=5,mttr=12/8760,inspect=1/26, name=&quot;e-gen set fails&quot;) tree1&lt;-addDemand(tree1, at=1, mttf=1.0, name=&quot;External power&quot;, name2=&quot;interruption&quot;) tree1&lt;-ftree.calc(tree1) tree1[,1:8] ## ID GParent CParent Level Type CFR PBF CRT ## 1 1 -1 -1 1 14 0.0002223396 3.045753e-07 0.001369866 ## 2 2 1 1 2 10 -1.0000000000 2.223396e-04 0.001369866 ## 3 3 2 2 3 11 0.0016369090 1.688518e-05 0.001369863 ## 4 4 3 3 4 2 0.2000000000 4.109158e-03 0.001369863 ## 5 5 3 3 4 2 0.2000000000 4.109158e-03 0.001369863 ## 6 6 2 2 3 12 0.0100000000 2.054579e-04 0.001369863 ## 7 7 6 6 4 4 -1.0000000000 5.000000e-02 -1.000000000 ## 8 8 6 6 4 2 0.2000000000 4.109158e-03 0.001369863 ## 9 9 1 1 2 3 1.0000000000 -1.000000e+00 -1.000000000 The fault tree exists in R as a dataframe object. We can view most output of interest in just the first 8 columns. Each node of the tree occupies a line of the dataframe and they are sequentially given a numbered ID. The output of calculations are in the CFR, PBF, and CRT columns as explained. CFR is the Conditional Fail Rate PBF is the Probability of Failure (or Failed State) CRT is the Conditional Repair Time (this will only be used on reversible conditions through the Priority AND gate.) In this case all mean time to failure (mttf) and mean time to repair (mttr) values were input as years, so the CFR and CRT are also reported in these units. Probability is of course unit-less. It is of course more pleasing to view the fault tree as a graphic, and in this regard the FaultTree package will not disappoint. Just add the following lines after the executed script above: ftree2html(tree1, write_file=TRUE) ## ID Parent Type CFR PBF CRT Cond ## 1 1 -1 14 0.0002223396 3.045753e-07 0.001369866 0 ## 2 2 1 10 -1.0000000000 2.223396e-04 0.001369866 1 ## 3 3 2 11 0.0016369090 1.688518e-05 0.001369863 0 ## 4 4 3 2 0.2000000000 4.109158e-03 0.001369863 0 ## 5 5 3 2 0.2000000000 4.109158e-03 0.001369863 0 ## 6 6 2 12 0.0100000000 2.054579e-04 0.001369863 0 ## 7 7 6 4 -1.0000000000 5.000000e-02 -1.000000000 1 ## 8 8 6 2 0.2000000000 4.109158e-03 0.001369863 0 ## 9 9 1 3 1.0000000000 -1.000000e+00 -1.000000000 0 ## Name Name2 ## 1 Site power loss ## 2 neither emergency generator operable ## 3 Independent failure of generators ## 4 e-gen set fails ## 5 e-gen set fails ## 6 Common cause failure of generators ## 7 Common cause beta factor ## 8 e-gen set fails ## 9 External power interruption browseURL(&#39;tree1.html&#39;) Now the image below should appear in your default browser. "],
["basics.html", "Chapter 2 Fault Tree Basics", " Chapter 2 Fault Tree Basics This second introductory essay assumes the user has installed R and the FaultTree package. If this is not the case please refer to ‘Getting started with FaultTree on R’. This essay will examine a simple example in Section 5.1 (page 55) in ‘Fault Tree Hand book with Aerospace Applications’ published by NASA. This document is available for free download. In this example we are encouraged to think of water flowing through two valves A and B. It could be more exciting to think of it as rocket fuel from Fuel Storage passing through pump A and valve B to a Rocket Engine. In the first instance we want to consider that the undesired event is ‘no flow to the Receiver’. This tree will be named ‘nasa1’ and the first line of our FaultTree script can be entered into the console as: nasa1&lt;-ftree.make(type=&quot;or&quot;, name=&quot;no flow to&quot;, name2=&quot;Receiver&quot;) Notice that the character combination ‘&lt;-’ forming a sort of arrow is an assignment operator in R. An equals sign ‘=’ would also work, but has not been used to distinguish it from argument assignment. This script line really hasn’t done much yet, but a fault tree object has been created, named ‘nasa1’, as a dataframe in R. A dataframe can be viewed by just typing its name at the &gt; prompt on the console: nasa1 ## ID GParent CParent Level Type CFR PBF CRT MOE PHF_PZ Condition Cond_Code ## 1 1 -1 -1 1 10 -1 -1 -1 0 -1 0 0 ## Interval Tag_Obj Name Name2 Description Unused1 Unused2 ## 1 -1 no flow to Receiver This is output from FaultTree version 0.0.12 and may change somewhat as development progresses to a substantial completion for CRAN release. The top event was created as an OR gate (type=”or”) because it is known that there will be two possible causes for lack of flow to the Receiver. Those causal events will be “no flow in Line 2” or “Component B blocks flow”. The existence of either event will result in no flow to Receiver. The dataframe has been generated with an ID of 1 to this top event by default. Negative-one (-1) values generally indicate no numeric value exists. The top gate has no parent node for either graphic display (GParent) nor calculation (CParent). The top event occupies Level 1 in the logical tree hierarchy. The OR gate type has been stored as a numeric value of 10. The name to be placed in the label box has been split to two lines using name and name2 arguments to the ftree.make function. Later fields of the dataframe will be discussed as progression is made to more complex models. One might ask, ‘how can one know how to enter arguments in the ftree.make function?’. R has a help system and developer’s are required to maintain manual pages for all exported functions on most repositories – particularly CRAN. To view the manual page for this or any function just precede the name of the function with a question mark in the R console: ?ftree.make This will load the help page in the default browser. In the case of ftree.make it can be seen that there are more arguments than were defined in our script. Function arguments are often pre-loaded with useful default values. Defaulted arguments do not need to be added to a script command. In a typical windows application one would expect the argument options to be presented in a dialogue window after some menu selection. Well, R is different. The next two script lines can be entered into the console as: nasa1&lt;-addLogic(nasa1, at=1, type=&quot;or&quot;, name=&quot;no flow in&quot;, name2=&quot;Line 2&quot;) nasa1&lt;-addProbability(nasa1, at=1, prob=0.1, name=&quot;Component B&quot;, name2=&quot;blocks flow&quot;) After this we can view select columns of the dataframe by entering: nasa1[,c(1:8,15,16)] This will result in the following output: A number of things can be reviewed here. It can be observed that the addLogic function is very similar to the ftree.make function with the exception of a first argument that seemingly repeats the tree name and the ‘at’ argument. The first argument passes the tree dataframe object into the function so it can be modified. The output of the function will be the modified dataframe object. This is an example of functional programming. The ‘at’ argument specifies the parent ID. Basic component event entries such as addProbability each have sufficiently different argument lists, so they have been independently implemented for each type. It has been noted earlier that these two events are each capable of causing loss of flow to the Receiver, which is our top event. Both of these are connected at the top node which has an ID of 1. In the dataframe it can be noted that the probability value on the third entry has been recorded as PBF. Calculations have not yet been conducted upwards, and they can’t until all logic nodes have component entries below them. Only component event entries pass in data. Also note that the basic event holding only a probability of failure is stored as type 4. As a point of R usage the specification of columns to be displayed in the output table is prepared as a vector concatenating a range and two independently listed columns. If you just enter the c(1:8,15,16) definition at the R console prompt you will see: c(1:8,15,16) There is enough information here to generate a meaningful graphic display. In order to do this we execute the following two lines: ftree2html(nasa1, write_file=TRUE) ## ID Parent Type CFR PBF CRT Cond Name Name2 ## 1 1 -1 10 -1 -1.0 -1 0 no flow to Receiver ## 2 2 1 10 -1 -1.0 -1 0 no flow in Line 2 ## 3 3 1 4 -1 0.1 -1 0 Component B blocks flow browseURL(&quot;nasa1.html&quot;) These graphic display lines can be executed many times as the tree is developed. The graphic view may be easier to interpret than the table view. As a free bit of information the ftree2html function also places a table view in the console. Notice that the ID value for the nodes is displayed in red font in the center of the graphic symbol. This is an extra help for determining the ‘at’ argument for subsequent event additions. The example tree can now be finalized with the addition of two more basic events: nasa1&lt;-addProbability(nasa1, at=2, prob=0.01, name=&quot;No Flow&quot;, name2=&quot;From Source&quot;) nasa1&lt;-addProbability(nasa1, at=2, prob=0.1, name=&quot;Component A&quot;, name2=&quot;blocks flow&quot;) The tree can now be calculated because there are no empty gates. That is we have component entries for all logic gate nodes. nasa1&lt;-ftree.calc(nasa1) Follow once again with: ftree2html(nasa1, write_file=TRUE) ## ID Parent Type CFR PBF CRT Cond Name Name2 ## 1 1 -1 10 -1 0.1981 -1 0 no flow to Receiver ## 2 2 1 10 -1 0.1090 -1 0 no flow in Line 2 ## 3 3 1 4 -1 0.1000 -1 0 Component B blocks flow ## 4 4 2 4 -1 0.0100 -1 0 No Flow From Source ## 5 5 2 4 -1 0.1000 -1 0 Component A blocks flow browseURL(&quot;nasa1.html&quot;) This is now a completed fault tree with quantification. The calculation for the OR gate sums its child entries. But, for probabilities this must be a probabilistic sum, since probabilities must always exist in the range less than one, greater than zero. The probabilistic sum performed at the OR gate at ID=2 is: 1-(1-0.01)*(1-0.1) ## [1] 0.109 Likewise the calculation performed in the top gate is: 1-(1-0.109)*(1-0.1) ## [1] 0.1981 It may be bothersome to some that I ignored the nodes with empty label boxes indicating “no flow in Line 3” and ‘no flow from source’ . The FaultTree package does not support the use of such empty nodes. Although this is not a recommended practice, it is possible to enter these as OR gates. The following script accomplishes this. Copy and paste all 10 lines of this script into the R console at once: nasa1a&lt;-ftree.make(type=&quot;or&quot;, name=&quot;no flow to&quot;, name2=&quot;Receiver&quot;) nasa1a&lt;-addLogic(nasa1a, at=1, type=&quot;or&quot;, name=&quot;no flow in&quot;, name2=&quot;Line 3&quot;) nasa1a&lt;-addLogic(nasa1a, at=2, type=&quot;or&quot;, name=&quot;no flow in&quot;, name2=&quot;Line 2&quot;) nasa1a&lt;-addProbability(nasa1a, at=2, prob=0.1, name=&quot;Component B&quot;, name2=&quot;blocks flow&quot;) nasa1a&lt;-addLogic(nasa1a, at=3, type=&quot;or&quot;, name=&quot;no flow in&quot;, name2=&quot;Line 1&quot;) nasa1a&lt;-addProbability(nasa1a, at=3, prob=0.1, name=&quot;Component A&quot;, name2=&quot;blocks flow&quot;) nasa1a&lt;-addProbability(nasa1a, at=5, prob=0.01, name=&quot;No Flow&quot;, name2=&quot;From Source&quot;) nasa1a&lt;-ftree.calc(nasa1a) ftree2html(nasa1a, write_file=TRUE) ## ID Parent Type CFR PBF CRT Cond Name Name2 ## 1 1 -1 10 -1 0.1981 -1 0 no flow to Receiver ## 2 2 1 10 -1 0.1981 -1 0 no flow in Line 3 ## 3 3 2 10 -1 0.1090 -1 0 no flow in Line 2 ## 4 4 2 4 -1 0.1000 -1 0 Component B blocks flow ## 5 5 3 10 -1 0.0100 -1 0 no flow in Line 1 ## 6 6 3 4 -1 0.1000 -1 0 Component A blocks flow ## 7 7 5 4 -1 0.0100 -1 0 No Flow From Source browseURL(&quot;nasa1a.html&quot;) Care has been taken to assure that code presented in the gray shaded, code blocks, can be simply copy and pasted from the browser to the R Console for initial ease of this introduction. A better practice would be to place scripts such as these in a simple text file. In such a file the longer lines of code are viewed as a single line. Such script files can be saved with a .R (or .r) extension and will be recognized by the R console as a source script. Using the menu selection File -&gt; Source R code. . . will load and run such scripts from the file system. The NASA document is likely pointing out the logical thought put into the development of the tree. While using FaultTree on R only the OR gate can accept such single input in this way. This expansion takes up a lot of graphic space and makes the script more complex. Alternatively it would have been possible to simply place all three basic events under the single OR gate at the top event ID=1. This is left as a student exercise. Continuing the text example we will now consider the case where isolation of flow is expected and the undesired top failure event is worded as “Inadvertent flow to Receiver”. This change in context results in the creation of AND gates in place of the OR gates created in nasa1. nasa2&lt;-ftree.make(type=&quot;and&quot;, name=&quot;Inadvertent flow&quot;, name2=&quot;to Receiver&quot;) nasa2&lt;-addLogic(nasa2, at=1, type=&quot;and&quot;, name=&quot;Inadvertent flow&quot;, name2=&quot;in Line 2&quot;) nasa2&lt;-addProbability(nasa2, at=1, prob=0.1, name=&quot;Component B&quot;, name2=&quot;passes flow&quot;) nasa2&lt;-addProbability(nasa2, at=2, prob=0.01, name=&quot;Inadvertent flow&quot;, name2=&quot;From Source&quot;) nasa2&lt;-addProbability(nasa2, at=2, prob=0.1, name=&quot;Component A&quot;, name2=&quot;passes flow&quot;) nasa2&lt;-ftree.calc(nasa2) ftree2html(nasa2, write_file=TRUE) ## ID Parent Type CFR PBF CRT Cond Name Name2 ## 1 1 -1 11 -1 1e-04 -1 0 Inadvertent flow to Receiver ## 2 2 1 11 -1 1e-03 -1 0 Inadvertent flow in Line 2 ## 3 3 1 4 -1 1e-01 -1 0 Component B passes flow ## 4 4 2 4 -1 1e-02 -1 0 Inadvertent flow From Source ## 5 5 2 4 -1 1e-01 -1 0 Component A passes flow browseURL(&quot;nasa2.html&quot;) In this example the same input probability values have been used for the basic component events, however since these represent different failure modes one would expect that real data would reflect differences in some of these inputs. The calculation at the AND gate is a simple multiplication of the probability inputs. The power of redundancy can be seen in this case assuming that Components A and B were installed to guard against inadvertent flow to the Receiver. This might have been more evident had we assumed that flow is normally expected to be available from the Source such that the fourth line of the above script were to be: nasa2&lt;-addProbability(nasa2, at=2, prob=0.99, name=&quot;Flow Available&quot;, name2=&quot;From Source&quot;) Many fault trees have been built using only probability inputs with combinations of OR and AND gates as have been demonstrated here. In fact, most demonstrations found on the web would suggest that this is all there is to FTA. But we are just getting started. "],
["non-repairable.html", "Chapter 3 Non-Repairable System Models", " Chapter 3 Non-Repairable System Models The genesis of fault tree analysis occurred during evaluation of the Minuteman Launch Control System. The technique progressed through the aerospace industry largely for aircraft, spacecraft and weapons safety studies. All of these models are characterized by a mission through which a system is expected to perform, without opportunity for repair. When quantified, the primary measure of interest is the probability of mission failure within a given duration. This, of course, is the complement of reliability, which is the probability of success over a stated time, under stated conditions. To explore this lesson an example found in Clifton Erickson’s course notes has been selected. This excellent review material can be downloaded at Fault Tree Analysis, Clifton A. Ericson II The example to be built using the FaultTree package is found on slide 53. A simplified diagram for this example has been modified from a later more complex example in the same text. The undesired event in this case is inadvertent arming of the warhead. Presumably the exposure time starts when the battery is connected to the circuit. A recommended script is as follows: arm1&lt;-ftree.make(type=&quot;or&quot;, name=&quot;Warhead Armed&quot;, name2=&quot;Inadvertently&quot;) arm1&lt;-addLogic(arm1, at= 1 , type=&quot;and&quot;, name=&quot;Arm Circuit&quot;, name2=&quot;Relays Closed&quot;) arm1&lt;-addExposed(arm1, at= 2, mttf=1/1.1e-6, exposure=10, tag=&quot;E1&quot;, name=&quot;Relay 1&quot;, name2=&quot;Fails Closed&quot;) arm1&lt;-addExposed(arm1, at= 2, mttf=1/1.1e-6, exposure=10, tag=&quot;E2&quot;, name=&quot;Relay 1&quot;, name2=&quot;Fails Closed&quot;) arm1&lt;-addLogic(arm1, at= 1, type=&quot;inhibit&quot;, name=&quot;Arm Power&quot;, name2=&quot;Is Present&quot;) arm1&lt;-addProbability(arm1, at= 5, prob=1, tag=&quot;W1&quot;, name=&quot;Battery Power&quot;, name2=&quot;Is Available&quot;) arm1&lt;-addLogic(arm1, at= 5, type=&quot;or&quot;, name=&quot;Arm Circuit Closed&quot;, name2=&quot;By Computer&quot;) arm1&lt;-addExposed(arm1, at= 7, mttf=1/1.1e-6, exposure=10, tag=&quot;E3&quot;, name=&quot;CPU&quot;, name2=&quot;Failure&quot;) arm1&lt;-addExposed(arm1, at= 7, mttf=1/1.1e-6, exposure=10, tag=&quot;E4&quot;, name=&quot;Software&quot;, name2=&quot;Failure&quot;) As before this is calculated with: arm1&lt;-ftree.calc(arm1) Notice that if you forget to make the assignment “arm1&lt;-” the ftree.calc function proceeds and a calculated dataframe is returned for display. But that dataframe will not be persistent unless it is assigned to a variable label. Since the original uncalculated arm1 is no longer of interest after calculation, the new calculated dataframe is stored using the original object name. And viewed with: ftree2html(arm1, write_file=TRUE) ## ID Parent Type CFR PBF CRT Cond Name ## 1 1 -1 10 -1.0e+00 2.199988e-05 -1 0 Warhead Armed ## 2 2 1 11 -1.0e+00 1.209987e-10 -1 0 Arm Circuit ## 3 3 2 5 1.1e-06 1.099994e-05 -1 0 Relay 1 ## 4 4 2 5 1.1e-06 1.099994e-05 -1 0 Relay 1 ## 5 5 1 12 -1.0e+00 2.199976e-05 -1 0 Arm Power ## 6 6 5 4 -1.0e+00 1.000000e+00 -1 1 Battery Power ## 7 7 5 10 -1.0e+00 2.199976e-05 -1 0 Arm Circuit Closed ## 8 8 7 5 1.1e-06 1.099994e-05 -1 0 CPU ## 9 9 7 5 1.1e-06 1.099994e-05 -1 0 Software ## Name2 ## 1 Inadvertently ## 2 Relays Closed ## 3 Fails Closed ## 4 Fails Closed ## 5 Is Present ## 6 Is Available ## 7 By Computer ## 8 Failure ## 9 Failure browseURL(&quot;arm1.html&quot;) There are a number of issues to point out here. First, the data for the basic component events is added to the tree using an addExposed function. The two pieces of quantification data are entered as mttf (consistent with other FaultTree addXxx functions) and exposure [time]. The Greek letter lambda is characteristically used to represent failure rate. The reciprocal of failure rate is the mean time to failure. Entries to function arguments in R can be an expression that returns the desired result. For clarity in what is being done mttf is entered as the reciprocal of the listed lambda. All entered units must be on the same basis. That is, the mean time to failure for all components in this example is on the order of 1 million hours (~100 years) and the exposure time for this mission is 10 hours. ID values are central to identification of all nodes when using FaultTree. A tag attribute provides a means of naming the component event entries and condition entries at the leaves of the tree. Tags may be more human identifiable combinations of letters and numbers that characterize the elements, and they are displayed above and to the right of the label box. While basic components have a resultant probability value ( the probability of failure), in this example “Battery Power is Available” represents a condition. Conditions are also quantified by a probability value. Obviously this condition probability does not represent failure; a clear distinction between the basic component events and this condition. Clifton Erickson’s course tutorial has placed this particular condition in a “house” graphic node. This is identifies a “condition present” and the condition value should be limited to 1. The house graphic has not been implemented in the FaultTree package as a matter of preference . Here a distinction for the condition entry is provided by using an INHIBIT gate. Note that the quantification is the same, whether an AND gate is used or the INHIBIT. For the non-repairable system model the use of INHIBIT for condition entries is purely a means of graphical distinction. The first entry to an INHIBIT gate will be taken as the condition by default, so ordering of the addXxx function lines in the FaultTree script can be significant. Since R allows assignment of function arguments using expressions that return a desired object, the example script can be rewritten to permit easy changing of all the mission exposure time values at once. warhead_exposure&lt;-10 arm2&lt;-ftree.make(type=&quot;or&quot;, name=&quot;Warhead Armed&quot;, name2=&quot;Inadvertently&quot;) arm2&lt;-addLogic(arm2, at= 1, type=&quot;and&quot;, name=&quot;Arm Circuit&quot;, name2=&quot;Relays Closed&quot;) arm2&lt;-addExposed(arm2, at= 2, mttf=1/1.1e-6, exposure=warhead_exposure, tag=&quot;E1&quot;, name=&quot;Relay 1&quot;, name2=&quot;Fails Closed&quot;) arm2&lt;-addExposed(arm2, at= 2, mttf=1/1.1e-6, exposure=warhead_exposure, tag=&quot;E2&quot;, name=&quot;Relay 2&quot;, name2=&quot;Fails Closed&quot;) arm2&lt;-addLogic(arm2, at= 1, type=&quot;inhibit&quot;, name=&quot;Arm Power&quot;, name2=&quot;Is Present&quot;) arm2&lt;-addProbability(arm2, at= 5, prob=1, tag=&quot;W1&quot;, name=&quot;Battery Power&quot;, name2=&quot;Is Available&quot;) arm2&lt;-addLogic(arm2, at= 5, type=&quot;or&quot;, name=&quot;Arm Circuit Closed&quot;, name2=&quot;By Computer&quot;) arm2&lt;-addExposed(arm2, at= 7, mttf=1/1.1e-6, exposure=warhead_exposure, tag=&quot;E3&quot;, name=&quot;CPU&quot;, name2=&quot;Failure&quot;) arm2&lt;-addExposed(arm2, at= 7, mttf=1/1.1e-6, exposure=warhead_exposure, tag=&quot;E4&quot;, name=&quot;Software&quot;, name2=&quot;Failure&quot;) The script above produces a tree that is no different than arm1. However, now warhead_exposure values can be changed to permit a study of the effect of mission time on the probability of the undesired event. Since we are running in the R environment the tree construction and calculation are performed programmatically. It is possible to program a loop collecting the outcome of interest from multiple tree calculations in a separate dataframe, like so: TimeStudy&lt;-data.frame(Exposure_Time=NULL, Prob_of_Failure=NULL) for(power in 0:7) { warhead_exposure&lt;-10^power arm2&lt;-ftree.make(type=&quot;or&quot;, name=&quot;Warhead Armed&quot;, name2=&quot;Inadvertently&quot;) arm2&lt;-addLogic(arm2, at= 1, type=&quot;and&quot;, name=&quot;Arm Circuit&quot;, name2=&quot;Relays Closed&quot;) arm2&lt;-addExposed(arm2, at= 2, mttf=1/1.1e-6, exposure=warhead_exposure, tag=&quot;E1&quot;, name=&quot;Relay 1&quot;, name2=&quot;Fails Closed&quot;) arm2&lt;-addExposed(arm2, at= 2, mttf=1/1.1e-6, exposure=warhead_exposure, tag=&quot;E2&quot;, name=&quot;Relay 2&quot;, name2=&quot;Fails Closed&quot;) arm2&lt;-addLogic(arm2, at= 1, type=&quot;inhibit&quot;, name=&quot;Arm Power&quot;, name2=&quot;Is Present&quot;) arm2&lt;-addProbability(arm2, at= 5, prob=1, tag=&quot;W1&quot;, name=&quot;Battery Power&quot;, name2=&quot;Is Available&quot;) arm2&lt;-addLogic(arm2, at= 5, type=&quot;or&quot;, name=&quot;Arm Circuit Closed&quot;, name2=&quot;By Computer&quot;) arm2&lt;-addExposed(arm2, at= 7, mttf=1/1.1e-6, exposure=warhead_exposure, tag=&quot;E3&quot;, name=&quot;CPU&quot;, name2=&quot;Failure&quot;) arm2&lt;-addExposed(arm2, at= 7, mttf=1/1.1e-6, exposure=warhead_exposure, tag=&quot;E4&quot;, name=&quot;Software&quot;, name2=&quot;Failure&quot;) arm2&lt;-ftree.calc(arm2) study_row&lt;-data.frame(Exposure_Time=warhead_exposure, Prob_of_Failure=arm2$PBF[1]) TimeStudy&lt;-rbind(TimeStudy, study_row) } TimeStudy ## Exposure_Time Prob_of_Failure ## 1 1e+00 2.199999e-06 ## 2 1e+01 2.199988e-05 ## 3 1e+02 2.199879e-04 ## 4 1e+03 2.198788e-03 ## 5 1e+04 2.187684e-02 ## 6 1e+05 2.061890e-01 ## 7 1e+06 9.385110e-01 ## 8 1e+07 1.000000e+00 By changing the range “0:7” for the power value in the for loop to “seq(0,7, by=.1)” a plot can be generated with a fairly smoothed line curve. plot(TimeStudy, log=&quot;x&quot;, type=&quot;l&quot;) "],
["cut-set.html", "Chapter 4 Cut Set Analysis", " Chapter 4 Cut Set Analysis During the development of fault trees there are times when a basic event entry for the same component with the same failure mode appears in more than one position in the tree. This occurs so frequently that the term Multiply Occurring Event (MOE) is widely used. At times replication may involve an entire branch of a tree as a Multiply Occurring Branch (MOB), in which case all component events comprising the duplicated branch are MOE’s. Depending on the design of the fault tree structure, or when a team of participants works on the same large tree, MOE’s may be distributed under one or more AND gates. Such occurrences may hide the true significance of certain events, rendering inaccuracies when the tree is calculated on a bottom-up, gate-by-gate fashion as the ftree.calc function in FaultTree does. Cut set analysis is widely performed to mitigate these risks in fault tree construction. A cut set is a distinct path of failure leading to the top undesired event. Upon initial dissection of a fault tree many cut sets are typically identified, but not all are unique. Repeated combinations of events may also be found in cut sets having the same number of events combined by an AND operation. A process of reduction using the laws of Boolean algebra is then used to identify only the truly unique minimal cut sets. Several algorithms have been identified for methodically identifying all cut sets in a fault tree and then reducing them to the minimal cut sets. The FaultTree package currently performs only one of the popular early algorithms referred to as Method for Obtaining CUt Sets (MOCUS). The source code is perhaps the best documentation of this algorithm for those interested in exploring this further. Since this is an open source effort all are encouraged to make this a study. For purposes of this discussion an example will be worked out to demonstrate the use. The chosen example has been obtained from Appendix B of Clifton Ericson’s “Fault Tree Analysis Primer” available for purchase at Amazon - Fault Tree Analysis Primer, Clifton A Ericson Presume a hypothetical power generation system driven off of a dual engine aircraft. Each engine can drive either or both generators associated with it, although one on each wing is initially a stand-by. Two of the total four generators must operate to produce sufficient power. A computer on the aircraft is responsible for identifying failure of any running generator and switching to a stand-by so as to avoid power failure. The undesired event is insufficient power. This will occur if 3 out of 4 generators cannot produce power. As sometimes happens during group study a consensus (or simply the loudest or highest ranking voice in the room) may focus first on the 3 out of 4 generator combinations that would result in insufficient power. Then, the fault tree is completed by analyzing the causal flow of events for for failure of each generator output back-to-front. Resulting in a fault tree generated by the following script. pwr&lt;-ftree.make(type=&quot;or&quot;, name=&quot;insufficient&quot;, name2=&quot;Electrical Power&quot;) pwr&lt;-addLogic(pwr, at=1, type=&quot;and&quot;, name=&quot;No Output&quot;, name2=&quot;G1, G2, G3&quot;) pwr&lt;-addLogic(pwr, at=2, type=&quot;or&quot;, name=&quot;No Power&quot;, name2=&quot;From G1&quot;) pwr&lt;-addLogic(pwr, at=3, type=&quot;or&quot;, name=&quot;No Output&quot;, name2=&quot;From G1&quot;) pwr&lt;-addProbability(pwr, at=3, prob=1e-4, tag=&quot;G1A&quot;, name=&quot;G1 Conn Open&quot;) pwr&lt;-addProbability(pwr, at=4, prob=1e-3, tag=&quot;G1&quot;, name=&quot;Generator G1&quot;, name2=&quot;Fails&quot;) pwr&lt;-addLogic(pwr, at=4, type=&quot;or&quot;, name=&quot;No Input&quot;, name2=&quot;To G1&quot;) pwr&lt;-addProbability(pwr, at=7, prob=1e-3, tag=&quot;E1&quot;, name=&quot;Engine E1&quot;, name2=&quot;Fails&quot;) pwr&lt;-addProbability(pwr, at=7, prob=1e-4, tag=&quot;G1B&quot;, name=&quot;Bleed Air To&quot;, name2=&quot;G1 Fails&quot;) pwr&lt;-addLogic(pwr, at=2, type=&quot;or&quot;, name=&quot;No Power&quot;, name2=&quot;From G2&quot;) pwr&lt;-addProbability(pwr, at=10, prob=1e-4, tag=&quot;G2A&quot;, name=&quot;G2 Conn Open&quot;) pwr&lt;-addLogic(pwr, at=10, type=&quot;or&quot;, name=&quot;No Output&quot;, name2=&quot;From G2&quot;) pwr&lt;-addLogic(pwr, at=12, type=&quot;or&quot;, name=&quot;No Input&quot;, name2=&quot;To G2&quot;) pwr&lt;-addDuplicate( pwr, at=13, dup_id=8) pwr&lt;-addProbability(pwr, at=13, prob=1e-4, tag=&quot;G2B&quot;, name=&quot;Bleed Air To&quot;, name2=&quot;G2 Fails&quot;) pwr&lt;-addProbability(pwr, at=12, prob=1e-3, tag=&quot;G2&quot;, name=&quot;Generator G2&quot;, name2=&quot;Fails&quot;) pwr&lt;-addLogic(pwr, at=12, type=&quot;or&quot;, name=&quot;Switch To&quot;, name2=&quot;G2 Fails&quot;) pwr&lt;-addProbability(pwr, at=17, prob=1e-4, tag=&quot;M1&quot;, name=&quot;Monitor M1&quot;, name2=&quot;Fails&quot;) pwr&lt;-addProbability(pwr, at=17, prob=1e-4, tag=&quot;S1&quot;, name=&quot;Switching S1&quot;, name2=&quot;Fails&quot;) pwr&lt;-addLogic(pwr, at=2, type=&quot;or&quot;, name=&quot;No Power&quot;, name2=&quot;From G3&quot;) pwr&lt;-addLogic(pwr, at=20, type=&quot;or&quot;, name=&quot;No Output&quot;, name2=&quot;From G3&quot;) pwr&lt;-addProbability(pwr, at=20, prob=1e-4, tag=&quot;G3A&quot;, name=&quot;G3 Conn Open&quot;) pwr&lt;-addProbability(pwr, at=21, prob=1e-3, tag=&quot;G3&quot;, name=&quot;Generator G3&quot;, name2=&quot;Fails&quot;) pwr&lt;-addLogic(pwr, at=21, type=&quot;or&quot;, name=&quot;No Input&quot;, name2=&quot;To G3&quot;) pwr&lt;-addProbability(pwr, at=24, prob=1e-3, tag=&quot;E2&quot;, name=&quot;Engine E2&quot;, name2=&quot;Fails&quot;) pwr&lt;-addProbability(pwr, at=24, prob=1e-4, tag=&quot;G3B&quot;, name=&quot;Bleed Air To&quot;, name2=&quot;G2 Fails&quot;) pwr&lt;-addLogic(pwr, at=1, type=&quot;and&quot;, name=&quot;No Output&quot;, name2=&quot;G1, G2, G4&quot;) pwr&lt;-addDuplicate( pwr, at=27, dup_id=3) pwr&lt;-addDuplicate( pwr, at=27, dup_id=10) pwr&lt;-addLogic(pwr, at=27, type=&quot;or&quot;, name=&quot;No Power&quot;, name2=&quot;From G4&quot;) pwr&lt;-addProbability(pwr, at=45, prob=1e-4, tag=&quot;G4A&quot;, name=&quot;G4 Conn Open&quot;) pwr&lt;-addLogic(pwr, at=45, type=&quot;or&quot;, name=&quot;No Output&quot;, name2=&quot;From G4&quot;) pwr&lt;-addLogic(pwr, at=47, type=&quot;or&quot;, name=&quot;No Input&quot;, name2=&quot;To G4&quot;) pwr&lt;-addDuplicate( pwr, at=48, dup_id=25) pwr&lt;-addProbability(pwr, at=48, prob=1e-3, tag=&quot;G4&quot;, name=&quot;Generator G4&quot;, name2=&quot;Fails&quot;) pwr&lt;-addProbability(pwr, at=47, prob=1e-4, tag=&quot;G4B&quot;, name=&quot;Bleed Air To&quot;, name2=&quot;G4 Fails&quot;) pwr&lt;-addLogic(pwr, at=47, type=&quot;or&quot;, name=&quot;Switch To&quot;, name2=&quot;G4 Fails&quot;) pwr&lt;-addDuplicate( pwr, at=52, dup_id=18) pwr&lt;-addDuplicate( pwr, at=52, dup_id=19) pwr&lt;-addLogic(pwr, at=1, type=&quot;and&quot;, name=&quot;No Output&quot;, name2=&quot;G1, G3, G4&quot;) pwr&lt;-addDuplicate( pwr, at=55, dup_id=3) pwr&lt;-addDuplicate( pwr, at=55, dup_id=20) pwr&lt;-addDuplicate( pwr, at=55, dup_id=45) pwr&lt;-addLogic(pwr, at=1, type=&quot;and&quot;, name=&quot;No Output&quot;, name2=&quot;G2, G3, G4&quot;) pwr&lt;-addDuplicate( pwr, at=80, dup_id=10) pwr&lt;-addDuplicate( pwr, at=80, dup_id=20) pwr&lt;-addDuplicate( pwr, at=80, dup_id=45) And viewed with: ftree2html(pwr, write_file=TRUE) browseURL(&quot;pwr.html&quot;) With a zoom out to 50% and some strategic node collapses of duplicated branches it is possible to contain the content of this tree in a single view. The FaultTree package does not currently support transfer gates. The script for this tree makes considerable use of the addDuplicate function, which does what is its name suggests. Both source and duplicated nodes are modified with magenta coloring for several attributes. For a source node an ‘S’ is placed at the upper left of the label box. An ‘R’ appears in this position for a repeated node. For repeated nodes the ID of the source is shown in the gate graphic rather than its actual node ID. This should not present a problem for identifying the placement of further nodes, since connections to sources or repeated nodes is not permitted once a duplication has been made. Probability values have been provided in this example, while none were listed in the book example. An order of magnitude was chosen to distinguish complex assemblies (engine or generator) from individual components (switches, valves, relays, etc.). It is trusted that all of these values are pessimistic, else no one would want to fly in aircraft. Calculation is not performed yet, as we wish to examine the cut set analysis first. The ftree.cutsets function will return the minimal cut sets for the named fault tree in a list of matrix objects. In addition to viewing this output it will be desirable to perform more manipulations. For this reason the output is assigned to an object name, ‘pwr_cs’ in this case. The command line is: pwr_cs&lt;-cutsets(pwr) The result viewed by retyping the object name to which output was assigned looks something like this: head(pwr_cs, n=1) lapply(pwr_cs, &quot;[&quot;, c(1:7)) This output is a list of matrices. The numerical order of the list items in double braces “[ [ # ] ]” indicates the order, or number of elements in the listed cut sets. Here there are no single order cut sets and no 4th order cut sets. The values shown in the matrices are node ID’s. Each row represents nodes combined by AND logic. For any duplicated nodes the ID is taken from the source of duplication. Here the actual output is truncated; however by scrolling through the output in the R Console it is quickly determined that there are 29 second order cut sets and 108 third order cut sets. This is good because it is exactly what Clifton Ericson also found. At this point the packaged code has identified the minimal cut sets, but the output is not yet in most useful form. For the next few steps we are going to utilize the R environment to manipulate the output as desired. Since we know that tags have been provided for all basic events in this example, it would be nice to translate the cut set matrices to show tags. This kind of operation across an entire matrix is facilitated by an apply function in R. After each operation it is recommended to view the object created by typing just the object name and enter. This will confirm what is going on. For those particularly interested, get the help pages ?apply and ?which to gain understanding on how this works. To get the tags for each element of the cut sets enter the following code: cs_tags2&lt;-apply(pwr_cs[[2]], c(1,2),function(x) pwr$Tag[which(pwr$ID==x)]) cs_tags3&lt;-apply(pwr_cs[[3]], c(1,2),function(x) pwr$Tag[which(pwr$ID==x)]) Similarly, it would be handy to have the probability values for each of the elements of the cut sets. cs_probs2&lt;-apply(pwr_cs[[2]], c(1,2),function(x) pwr$PBF[which(pwr$ID==x)]) cs_probs3&lt;-apply(pwr_cs[[3]], c(1,2),function(x) pwr$PBF[which(pwr$ID==x)]) Since each row of the cut set represents a single probability resulting from the product of its elements, it is possible to build a probability column to add to the cut set tags now as a dataframe. cs_tags2&lt;-cbind(cs_tags2, data.frame(&#39;prob&#39;=apply(cs_probs2, 1, function(x) prod(x)))) cs_tags3&lt;-cbind(cs_tags3, data.frame(&#39;prob&#39;=apply(cs_probs3, 1, function(x) prod(x)))) R details – There is a bit of sleight-of-hand going on at this point. Since the cs_tags matrices contained all character entries, and we wish to add a numeric column we have to force the new cs_tags objects to be dataframes. Dataframes can hold different object types as long as the columns have consistent types within. Now, it would be nice to combine these dataframes and order the cut sets according to probability (decreasing) and tag text values (increasing). First, a column of empty values (NA) must be added to cs_tags2 to give same number of rows as cs_tags3. Then the column names need to assigned as the same . Finally the two objects can be combined to one and sorted (ordered). Lastly, the rows are re-numbered for ascetics. nas&lt;-rep(NA,length(cs_tags2[,1])) cs_tags2&lt;-cbind(nas,cs_tags2) names(cs_tags2)&lt;-names(cs_tags3) all_cs&lt;-rbind(cs_tags2, cs_tags3) all_cs&lt;-all_cs[order(-all_cs[,4],all_cs[,1], all_cs[,2], all_cs[,3],na.last=FALSE), ] row.names(all_cs)&lt;-as.character(1:length(all_cs[,1])) The resulting all_cs dataframe provides an importance view of all of the cut sets, since it ranks the probability of each distinct path to failure. To be honest the ftree.cutsets function should return such an importance view object automatically. This will require coding the steps detailed in this section into the FaultTree source. However there are still unanswered questions as to how so called, non-coherent, trees built on the repairable system model should be handled. Currently all specialty gates will be treated as AND combinations and effort is required to restore full description of each cut set. For now this is left for analyst interpretation using the R environment. Now, this example can be accurately calculated by taking the probabilistic sum of all unique, minimal cut set probabilities. 1-prod(1-all_cs$prob) ## [1] 6.686892e-06 The original fault tree can be calculated and viewed as in the past, or for a shortcut to the probability of the top event: pwr &lt;-ftree.calc(pwr) pwr $PBF[1] ## [1] 4.847278e-08 What happened? Calculation of the example tree according to gate-by-gate calculations reveals a significant deviation! The original fault tree was constructed under the assumption that the generation of power was based purely on a 2 out of 4 redundancy of generators. Once initiated down this path the generation of second order events leading to the top event became unlikely. Clearly, if both engines fail there would be no means for generation of power. Likewise, if a single engine were to fail and one of the generators on the other side were to fail only one generator would remain available. Finally, if either engine or any operating generator were to fail there would be a dependency on the computer and switching systems to activate a stand-by. None of these cases were considered during construction of the original fault tree. It is almost magical that the cut set analysis is able to identify these events. The situation demonstrated by this example has lead some practitioners to eschew gate-by-gate calculation whatsoever. In reality it appears that fault tree practitioners should be aware of the risks and utilize cut set analysis to check their work. One could argue that the risk is due to inaccurate fault tree construction; however, cut set analysis is available to aid in checking such oversights and is invaluable for that purpose. It is left as a student exercise to build a more accurate fault tree based on the knowledge gained through cut set analysis. Start with a causal approach rather than functional. "],
["repairable.html", "Chapter 5 Repairable System Models", " Chapter 5 Repairable System Models Following the initial successes of fault tree analysis in the aerospace arena through the 1960’s, the Rasmussen report of the mid-1970’s launced the U.S. nuclear industry’s embrace of fault tree analysis and probabilistic risk assessment. Concern that loss of reactor core cooling leading to a loss of containment “China syndrome” caught the public attention. As historical backdrop one should recall that manned flight to the moon first occurred in 1969, while the oil embargo of 1973 lead to a major expansion in the construction of nuclear power generation. Additionally the 1974 Flixborough incident in England placed new emphasis on process safety in the chemical, oil and gas industries including use of fault tree analysis. This expanded use of fault tree techniques introduced a new aspect in that the repair or replacement of failed components was expected to maintain a continuous operation. In this realm the probability of failure over a mission (unreliability) is replaced by probability of a failed state over time (unavailability), while frequency of failure becomes the focus of most “top” undesired events. In this model, repair time becomes a required input in addition to fail rate for characterization of components. To introduce this topic consider a hypothetical coolant pumping scenario. The undesired event in this example is loss of adequate coolant flow. Such a loss to an exothermic process whether chemical or nuclear can lead to significant safety concern. The coolant is propelled by a pair of centrifugal pumps provided in a shared load array for redundancy. Adequate cooling flow can be provided as long as a one of the two pumps is in operation. A flow control valve on the combined discharge of the pumps back-pressures the pumps causing them to “walk up” the pump curve to reduce coolant flow to a normal rate as both pumps run continuously. This control saves power and reduces wear on downstream components. Check valves on the discharge of each pump prevent flow from recycling backwards through a non-operating pump. Both pumps are electric motor driven. The power supply is conditioned by a transformer and controlled by several breakers. The following table summarizes the input parameters: These are fairly realistic values for failure. Repair times reflect assumptions regarding availability of replacement components, parts, and repair personnel. A fault tree for this system is constructed, calculated, and viewed by the following script: cool&lt;-ftree.make(type=&quot;or&quot;, name=&quot;Coolant Flow&quot;, name2=&quot;Insufficient&quot;) cool&lt;-addLogic(cool, at= 1, type=&quot;and&quot;, name=&quot;Pumps Fail&quot;, name2=&quot;Independently&quot;) cool&lt;-addLogic(cool, at=1, type=&quot;or&quot;, name=&quot;Common Cause&quot;, name2=&quot;Pumping Failure&quot;) cool&lt;-addLogic(cool, at=2, type=&quot;or&quot;, name=&quot;Pump 1&quot;, name2=&quot;Failure&quot;) cool&lt;-addActive(cool, at=4, mttf=30, mttr=24/8760, tag=&quot;P1&quot;, name=&quot;Pump Impeller&quot;, name2=&quot;Fails&quot;) cool&lt;-addActive(cool, at=4, mttf=10, mttr=24/8760, tag=&quot;P1a&quot;, display_under=5, name=&quot;Pump Bearings&quot;, name2=&quot;Fail&quot;) cool&lt;-addActive(cool, at=4, mttf=6, mttr=12/8760, tag=&quot;P1b&quot;, display_under=6, name=&quot;Pump Seal&quot;, name2=&quot;Fails&quot;) cool&lt;-addActive(cool, at=4, mttf=10, mttr=24/8760, tag=&quot;M1&quot;, display_under=7, name=&quot;Pump Motor&quot;, name2=&quot;Fails&quot;) cool&lt;-addActive(cool, at=4, mttf=25, mttr=8/8760, tag=&quot;B1&quot;, display_under=8, name=&quot;Pump Motor Control&quot;, name2=&quot;Breaker Opens&quot;) cool&lt;-addLogic(cool, at=2, type=&quot;or&quot;, name=&quot;Pump 2&quot;, name2=&quot;Failure&quot;) cool&lt;-addActive(cool, at=10, mttf=30, mttr=24/8760, tag=&quot;P2&quot;, name=&quot;Pump Impeller&quot;, name2=&quot;Fails&quot;) cool&lt;-addActive(cool, at=10, mttf=10, mttr=24/8760, tag=&quot;P2a&quot;, display_under=11, name=&quot;Pump Bearings&quot;, name2=&quot;Fail&quot;) cool&lt;-addActive(cool, at=10, mttf=6, mttr=12/8760, tag=&quot;P2b&quot;, display_under=12, name=&quot;Pump Seal&quot;, name2=&quot;Fails&quot;) cool&lt;-addActive(cool, at=10, mttf=10, mttr=24/8760, tag=&quot;M2&quot;, display_under=13, name=&quot;Pump Motor&quot;, name2=&quot;Fails&quot;) cool&lt;-addActive(cool, at=10, mttf=25, mttr=8/8760, tag=&quot;B2&quot;, display_under=14, name=&quot;Pump Motor Control&quot;, name2=&quot;Breaker Opens&quot;) cool&lt;-addLogic(cool, at=3, type=&quot;or&quot;, name=&quot;Flow Control&quot;, name2=&quot;Restricts Flow&quot;) cool&lt;-addActive(cool, at=16, mttf=25, mttr=8/8760, tag=&quot;FV&quot;, name=&quot;Flow Valve Closed&quot;, name2=&quot;By Positioner&quot;) cool&lt;-addActive(cool, at=16, mttf=100, mttr=8/8760, tag=&quot;FC&quot;, display_under=17, name=&quot;Flow Valve Closed&quot;, name2=&quot;By Flow Controller&quot;) cool&lt;-addActive(cool, at=16, mttf=100, mttr=8/8760, tag=&quot;FT&quot;, display_under=18, name=&quot;Flow Valve Closed&quot;, name2=&quot;By Flow Transmitter&quot;) cool&lt;-addLogic(cool, at=3, type=&quot;or&quot;, name=&quot;Flow Recycles Through&quot;, name2=&quot;Failed Check Valve&quot;) cool&lt;-addLogic(cool, at=20, type=&quot;inhibit&quot;, name=&quot;Pump 1 Stops&quot;, name2=&quot;with CV1 Failed&quot;) cool&lt;-addProbability(cool, at=21, prob= .01, tag=&quot;CV1&quot;, name=&quot;Check Valve&quot;, name2=&quot;Fails on Demand&quot;) cool&lt;-addDuplicate(cool, at=21, dup_id=4) cool&lt;-addLogic(cool, at=20, type=&quot;inhibit&quot;, name=&quot;Pump 2 Stops&quot;, name2=&quot;with CV2 Failed&quot;) cool&lt;-addProbability(cool, at=29, prob= .01, tag=&quot;CV2&quot;, name=&quot;Check Valve&quot;, name2=&quot;Fails on Demand&quot;) cool&lt;-addDuplicate(cool, at=29, dup_id=10) cool&lt;-addLogic(cool, at=3, type=&quot;or&quot;, name=&quot;Power Interrupted&quot;, name2=&quot;To all Pumps&quot;) cool&lt;-addActive(cool, at=37, mttf=25, mttr=12/8760, tag=&quot;B3&quot;, name=&quot;MCC Breaker&quot;, name2=&quot;Opens&quot;) cool&lt;-addActive(cool, at=37, mttf=25, mttr=12/8760, tag=&quot;B4&quot;, display_under=38, name=&quot;Transformer Breaker&quot;, name2=&quot;Opens&quot;) cool&lt;-addActive(cool, at=37, mttf=300, mttr=72/8760, tag=&quot;TX&quot;, display_under=39, name=&quot;Transformer&quot;, name2=&quot;Fails&quot;) cool&lt;-ftree.calc(cool) ftree2html(cool, write_file=TRUE) ## ID Parent Type CFR PBF CRT Cond ## 1 1 -1 10 0.1529277786 2.106430e-04 0.0013777977 0 ## 2 2 1 11 0.0007944452 8.164842e-07 0.0010277413 0 ## 3 3 1 10 0.1521333333 2.098267e-04 0.0013796246 0 ## 4 4 2 10 0.4400000000 9.035952e-04 0.0020554827 0 ## 5 5 4 1 0.0333333333 9.131586e-05 0.0027397260 0 ## 6 6 4 1 0.1000000000 2.738976e-04 0.0027397260 0 ## 7 7 4 1 0.1666666667 2.282584e-04 0.0013698630 0 ## 8 8 4 1 0.1000000000 2.738976e-04 0.0027397260 0 ## 9 9 4 1 0.0400000000 3.652835e-05 0.0009132420 0 ## 10 10 2 10 0.4400000000 9.035952e-04 0.0020554827 0 ## 11 11 10 1 0.0333333333 9.131586e-05 0.0027397260 0 ## 12 12 10 1 0.1000000000 2.738976e-04 0.0027397260 0 ## 13 13 10 1 0.1666666667 2.282584e-04 0.0013698630 0 ## 14 14 10 1 0.1000000000 2.738976e-04 0.0027397260 0 ## 15 15 10 1 0.0400000000 3.652835e-05 0.0009132420 0 ## 16 16 3 10 0.0600000000 5.479227e-05 0.0009132545 0 ## 17 17 16 1 0.0400000000 3.652835e-05 0.0009132420 0 ## 18 18 16 1 0.0100000000 9.132337e-06 0.0009132420 0 ## 19 19 16 1 0.0100000000 9.132337e-06 0.0009132420 0 ## 20 20 3 10 0.0088000000 1.807182e-05 0.0020554920 0 ## 21 21 20 12 0.0044000000 9.035952e-06 0.0020554827 0 ## 22 22 21 4 -1.0000000000 1.000000e-02 -1.0000000000 1 ## 23 23 21 10 0.4400000000 9.035952e-04 0.0020554827 0 ## 24 24 23 1 0.0333333333 9.131586e-05 0.0027397260 0 ## 25 25 23 1 0.1000000000 2.738976e-04 0.0027397260 0 ## 26 26 23 1 0.1666666667 2.282584e-04 0.0013698630 0 ## 27 27 23 1 0.1000000000 2.738976e-04 0.0027397260 0 ## 28 28 23 1 0.0400000000 3.652835e-05 0.0009132420 0 ## 29 29 20 12 0.0044000000 9.035952e-06 0.0020554827 0 ## 30 30 29 4 -1.0000000000 1.000000e-02 -1.0000000000 1 ## 31 31 29 10 0.4400000000 9.035952e-04 0.0020554827 0 ## 32 32 31 1 0.0333333333 9.131586e-05 0.0027397260 0 ## 33 33 31 1 0.1000000000 2.738976e-04 0.0027397260 0 ## 34 34 31 1 0.1666666667 2.282584e-04 0.0013698630 0 ## 35 35 31 1 0.1000000000 2.738976e-04 0.0027397260 0 ## 36 36 31 1 0.0400000000 3.652835e-05 0.0009132420 0 ## 37 37 3 10 0.0833333333 1.369735e-04 0.0016439077 0 ## 38 38 37 1 0.0400000000 5.479152e-05 0.0013698630 0 ## 39 39 37 1 0.0400000000 5.479152e-05 0.0013698630 0 ## 40 40 37 1 0.0033333333 2.739651e-05 0.0082191781 0 ## Name Name2 ## 1 Coolant Flow Insufficient ## 2 Pumps Fail Independently ## 3 Common Cause Pumping Failure ## 4 Pump 1 Failure ## 5 Pump Impeller Fails ## 6 Pump Bearings Fail ## 7 Pump Seal Fails ## 8 Pump Motor Fails ## 9 Pump Motor Control Breaker Opens ## 10 Pump 2 Failure ## 11 Pump Impeller Fails ## 12 Pump Bearings Fail ## 13 Pump Seal Fails ## 14 Pump Motor Fails ## 15 Pump Motor Control Breaker Opens ## 16 Flow Control Restricts Flow ## 17 Flow Valve Closed By Positioner ## 18 Flow Valve Closed By Flow Controller ## 19 Flow Valve Closed By Flow Transmitter ## 20 Flow Recycles Through Failed Check Valve ## 21 Pump 1 Stops with CV1 Failed ## 22 Check Valve Fails on Demand ## 23 Pump 1 Failure ## 24 Pump Impeller Fails ## 25 Pump Bearings Fail ## 26 Pump Seal Fails ## 27 Pump Motor Fails ## 28 Pump Motor Control Breaker Opens ## 29 Pump 2 Stops with CV2 Failed ## 30 Check Valve Fails on Demand ## 31 Pump 2 Failure ## 32 Pump Impeller Fails ## 33 Pump Bearings Fail ## 34 Pump Seal Fails ## 35 Pump Motor Fails ## 36 Pump Motor Control Breaker Opens ## 37 Power Interrupted To all Pumps ## 38 MCC Breaker Opens ## 39 Transformer Breaker Opens ## 40 Transformer Fails browseURL(&quot;cool.html&quot;) This script utilizes the addActive function to define basic events. Active components are typically found to be operating. However the true determinant is that failures of active components will be realized immediately. Since this is a repairable model, both mttf and mttr values are required to define an active component. The display_under argument has been used in some instances. This argument simply permits the graphic display of sibling basic events to display in a vertical chain-like fashion under an OR gate. When this argument is set, checks are made to verify common parentage under an OR gate and then modification is made to the GParent field of the component row in the dataframe. In this case a wide display of 5 children under each appearance of the OR gate defining single pump failure would have been difficult to view if placed horizontally. Each of the check valves on pump discharge were modeled as a condition having a failed state probability. These check valves would not pass the active component definition, because it is not possible to tell that such a check valve may have been corrupted during normal system operation. The unavailability of each active component is calculated according to mttr/(mttf+mttr). This is the probability that the component is in a failed state over time. The fail rate, appearing in the graphic for each active component is 1/mttf. All time units must be maintained consistent on input. In this case years were chosen such that hours of repair time must be input as hours/8760 so that the repair time is represented as the fraction of a year. In the OR gates the output probability is the result of a probabilistic sum from the input events, identical to the calculation under the non-repairable model. The combined fail rate is the direct sum of input fail rates. The repair time is calculated based on combined fail rate and active component unavailability to represent a mean repair time. At the INHIBIT gates, the fail rate and unavailability of individual pump failure as combined in the duplicated OR gate are multiplied by the probability of a failed check valve. If only 1% of the time a check valve is in a failed state, then only 1% of the times that the single pump fails will result in the recycle failure. An assumption is applied that the repair time for a single pump failure is unchanged, therefore the resultant unavailability after the inhibit calculation is the product of the condition probability and the feeding node unavailability. The AND gate calculation is similar to two INHIBIT gates combined by an OR. Independent dual failure occurs under the condition that one component is in a failed state when the other fails. Two inhibit gates combined this way would be slightly inaccurate due to double counting of the times when both are down. The actual ‘cross-product’ calculation for fail rates at the AND gate is performed by the following formula: fail_rate1 * prob2 + fail_rate2 * prob1 – (fail_rate1+fail_rate2) * prob1 *prob2. Unavailability probabilities are combined in the AND as a product of input probabilities, identical to the calculation under the non-repairable model. The repair time after AND combination is then calculated based on the combined fail rate and active component unavailability values similar to the OR gate. It is a recommended student exercise to perform a check of the gate calculations for this example in a spreadsheet to confirm understanding of these processes. In this example the flow control loop places a significant burden on the success of adequate cooling. It is not uncommon to find features placed in a design for safety, energy efficiency, or even presumed reliability enhancement that impact the undesired event adversely. It can be more effective in cases such as this for the fault tree analyst not to attempt elimination of the feature (which is sure to encounter resistance), but to identify recommendations that can enhance the system with them in place. The flow control loop in this example is contributing no more than half of the quantified fail rate for the top event. Simply having both pumps driven by electric motor is of equivalent importance. Typically if order of magnitude improvement is required, features such as steam and/or diesel powered pumps in a secondary cooling system might be considered. Although not examined in this example, a diversity in the source of coolant might be justified as a secondary backup. The primary focus on importance is the contribution to the fail rate in OR gates immediately under the top event. The probability values, unavailability, is of lesser importance until failure of this system is considered a condition for combination with other protections. "],
["latent-events.html", "Chapter 6 Latent Component Events 6.1 Using the R Environment to Alter Inspection Intervals", " Chapter 6 Latent Component Events The identification of latency is perhaps one of the most valuable contributions to safety and reliability engineering. Latent component events are characterized by hidden failures (or faults) which represent conditions under which additional failures will combine to propagate system failure, or undesired events. Similar to exposure time with the non-repairable model, latent events have exposure over an interval between inspections accompanied by any needed repair. The longer the interval, the higher the probability that a latent component will be in a failed state. Scheduling and even designing a system to permit inspection, proof or validation tests becomes key to risk reduction. An example to be studied for this topic is presented on Page 24 of the DOE Handbook [for] Chemical Process Hazards Analysis. In this study the undesired event is HF Vaporizer Rupture. The fault tree studied here will be embellished with hypothetical data and developed in a bit more detail than the milquetoast version provided in the handbook. Although not a factor in the 1992 release event at Oakridge, nor in the text of the handbook, this example study will consider the combination of rupture disk and relief valve, PRV4, in more detail. This combination of relief devices is required in such corrosive service as HF gas. If the relief valve were not isolated in this way it would be subject to corrosion due to minute leakage through the safety valve seat permitting HF vapor to contact moist ambient air. However this required feature will add risk to the performance of the pressure relief function. In particular it is somewhat likely that the rupture disk may form a pin-hole leak that will pressurize the piping inside V28, PRV4 and the rupture disk. Thus rendering the rupture disk incapable of performing its required function upon process pressure increase. In this case latency is observed in the primary function of the relief valve, minute leakage in the rupture disk, the indication ability of the pressure gauge, and in the manual position of the isolation valves V-20 and V-21. three inspection protocols have been envisioned for this system In order to mitigate the effects of the potentially hidden flaws as follows: rv_test This is a rather expensive test that must be done while the system has been decommissioned, likely for other extensive maintenance. Relief valve PRV4 will be replaced with a new or reconditioned valve. The old valve will be sent out for bench test and any required reconditioning. Upon restoration of the system a pi_test and walkby will also be completed. pi_test This test involves applying a modest pressure of nitrogen through a connection at V28. During this test verification is made of the pressure gage integrity. It is also likely that some disposable testing device might be used to verify that no leakage of HF gas is occurring through the rupture disk. Upon completion of a pi_test a walkby will also be completed. walk-by This easiest test requires no intervention on the system other than possible call for remediation. The operator/inspector will log the pressure indicated on the pressure gauge and make note of the position of the isolation valves V20 and V21. The expense of testing usually places a limit on frequency of tests. For this example it is first assumed that the rv_test is scheduled every 3 years. The pi_test is conducted annually and a monthly log is required from the operators from a walkby inspection. Various assumptions have been made on failure occurrence for many items. No more detail has been developed for the overpressure demands than in the DOE handbook. For the latent events an input value, pzero=0, has been utilized since the undesired event is unlikely risked during conduct of testing including any required remediation. A sample fault tree is built using the following script: rv_test=3 pi_test=1 walkby=1/12 hf&lt;-ftree.make(type=&quot;or&quot;, name=&quot;HF Vaporizer&quot;, name2=&quot;Rupture&quot;) hf&lt;-addLogic(hf, at=1, type=&quot;inhibit&quot;, name=&quot;Overpressure&quot;, name2=&quot;Unrelieved&quot;) hf&lt;-addDemand(hf, at=1, mttf=1e6, name= &quot;Vaporizer Rupture&quot;, name2=&quot;Due to Stress/Fatigue&quot;) hf&lt;-addLogic(hf, at=2, type=&quot;or&quot;, name=&quot;Pressure Relief System&quot;, name2=&quot;in Failed State&quot;) hf&lt;-addLogic(hf, at=2, type=&quot;or&quot;, name=&quot;Overpressure&quot;, name2=&quot;Occurs&quot;) hf&lt;-addLogic(hf, at=4, type=&quot;or&quot;, name=&quot;Pressure Relief&quot;, name2=&quot;Isolated&quot;) hf&lt;-addLatent(hf, at=6, mttf=10, pzero=0, inspect=walkby, name=&quot;Valve 20&quot;, name2=&quot;Left Closed&quot;) hf&lt;-addLatent(hf, at=6, mttf=10, pzero=0, inspect=walkby, display_under=7, name=&quot;Valve 21&quot;, name2=&quot;Left Closed&quot;) hf&lt;-addLogic(hf, at=4, type=&quot;or&quot;, name=&quot;Rupture Disk Fails&quot;, name2=&quot;to Open at Design Pt.&quot;) hf&lt;-addLogic(hf, at=9, type=&quot;or&quot;, name=&quot;Installation/Mfr&quot;, name2=&quot;Errors&quot;) hf&lt;-addProbability(hf, at=10, prob=.001, name=&quot;Rupture Disk&quot;, name2=&quot;Installed Upside Down&quot;) hf&lt;-addProbability(hf, at=10, prob=.001, display_under=11, name=&quot;Wrong Rupture Disk&quot;, name2=&quot;Installed&quot;) hf&lt;-addProbability(hf, at=10, prob=.001, display_under=12, name=&quot;Rupture Disk&quot;, name2=&quot;Manuf. Error&quot;) hf&lt;-addLogic(hf, at=9, type=&quot;or&quot;, name=&quot;Pressure Between Disk&quot;, name2=&quot;and Relief Valve&quot;) hf&lt;-addLogic(hf, at=14, type=&quot;inhibit&quot;, name=&quot;Pressure NOT&quot; , name2=&quot;Detectable by PI&quot;) hf&lt;-addLatent(hf, at=15, mttf=10, pzero=0, inspect=pi_test, name=&quot;Pressure Gage&quot;, name2=&quot;Failed Low Position&quot;) hf&lt;-addLatent(hf, at=15, mttf=10, pzero=0, inspect=pi_test, name=&quot;Rupture Disk Leak&quot;, name2=&quot;Undetected&quot;) hf&lt;-addLogic(hf, at=14, type=&quot;inhibit&quot;, name=&quot;Pressure&quot; , name2=&quot;Detectable by PI&quot;) hf&lt;-addProbability(hf, at=18, prob=1-4.8374e-2, name=&quot;Pressure Gage&quot;, name2=&quot;Detects Pressure&quot;) hf&lt;-addLatent(hf, at=18, mttf=10, pzero=0, inspect=walkby, name=&quot;Rupture Disk Leak&quot;, name2=&quot;Detectable&quot;) hf&lt;-addLogic(hf, at=4, type=&quot;or&quot;, name=&quot;Pressure Relief Fails&quot;, name2=&quot; to Open at Design Pt&quot;) hf&lt;-addLatent(hf, at=21, mttf=300, pzero=0, inspect=rv_test, name=&quot;Pressure Relief&quot;, name2=&quot;set too high&quot;) hf&lt;-addLatent(hf, at=21, mttf=300, pzero=0, inspect=rv_test, name=&quot;Pressure Relief Unable&quot;, name2=&quot;to Open at Design Pt&quot;) hf&lt;-addDemand(hf, at=5, mttf=10, name= &quot;High Pressure&quot;, name2=&quot;Feed to Vaporizer&quot;) hf&lt;-addDemand(hf, at=5, mttf=10, name= &quot;Vaporizer Heating&quot;, name2=&quot;Runaway&quot;) The fault tree is calculated then prepared for view in the browser: hf&lt;-ftree.calc(hf) ftree2html(hf, write_file=TRUE) ## ID Parent Type CFR PBF CRT Cond ## 1 1 -1 10 0.005450476 -1.000000000 -1 0 ## 2 2 1 12 0.005449476 -1.000000000 -1 0 ## 3 3 1 3 0.000001000 -1.000000000 -1 0 ## 4 4 2 10 -1.000000000 0.027247379 -1 1 ## 5 5 2 10 0.200000000 -1.000000000 -1 0 ## 6 6 4 10 0.200000000 0.008292968 -1 0 ## 7 7 6 2 0.100000000 0.004155117 -1 0 ## 8 8 6 2 0.100000000 0.004155117 -1 0 ## 9 9 4 10 0.100000018 0.009263091 -1 0 ## 10 10 9 10 -1.000000000 0.002997001 -1 0 ## 11 11 10 4 -1.000000000 0.001000000 -1 0 ## 12 12 10 4 -1.000000000 0.001000000 -1 0 ## 13 13 10 4 -1.000000000 0.001000000 -1 0 ## 14 14 9 10 0.100000018 0.006284926 -1 0 ## 15 15 14 12 0.004837418 0.002340061 -1 0 ## 16 16 15 2 -1.000000000 0.048374180 -1 1 ## 17 17 15 2 0.100000000 0.048374180 -1 0 ## 18 18 14 12 0.095162600 0.003954117 -1 0 ## 19 19 18 4 -1.000000000 0.951626000 -1 1 ## 20 20 18 2 0.100000000 0.004155117 -1 0 ## 21 21 4 10 0.006666667 0.009941916 -1 0 ## 22 22 21 2 0.003333333 0.004983375 -1 0 ## 23 23 21 2 0.003333333 0.004983375 -1 0 ## 24 24 5 3 0.100000000 -1.000000000 -1 0 ## 25 25 5 3 0.100000000 -1.000000000 -1 0 ## Name Name2 ## 1 HF Vaporizer Rupture ## 2 Overpressure Unrelieved ## 3 Vaporizer Rupture Due to Stress/Fatigue ## 4 Pressure Relief System in Failed State ## 5 Overpressure Occurs ## 6 Pressure Relief Isolated ## 7 Valve 20 Left Closed ## 8 Valve 21 Left Closed ## 9 Rupture Disk Fails to Open at Design Pt. ## 10 Installation/Mfr Errors ## 11 Rupture Disk Installed Upside Down ## 12 Wrong Rupture Disk Installed ## 13 Rupture Disk Manuf. Error ## 14 Pressure Between Disk and Relief Valve ## 15 Pressure NOT Detectable by PI ## 16 Pressure Gage Failed Low Position ## 17 Rupture Disk Leak Undetected ## 18 Pressure Detectable by PI ## 19 Pressure Gage Detects Pressure ## 20 Rupture Disk Leak Detectable ## 21 Pressure Relief Fails to Open at Design Pt ## 22 Pressure Relief set too high ## 23 Pressure Relief Unable to Open at Design Pt ## 24 High Pressure Feed to Vaporizer ## 25 Vaporizer Heating Runaway browseURL(&quot;hf.html&quot;) In this example the occurrence of the undesired event, HF vaporizer rupture, is so severe that restoration of the pressure relief system from its failed state is irrelevant. This is a condition that presents only a probability to an inhibit gate for combination with the overpressure demands. Demands are typically events that can have devastating effect, but insignificant duration. Like lightning striking. Under the OR gate at node 14 two inhibit gates are used to distinguish two complimentary conditions. The condition at node 15 is failure of pressure gauge in such a manner that pressure between the rupture disk and relief valve would not be detected. This state also alters the nature of the latent failure of a pin-hole leak in the rupture disk because its detection interval now depends on the pi_test. Node 18 has a complimentary probability for when the pressure gauge is not in a failed state. One way to place an accurate probability at the event at node 19 is to first calculate the tree (with a probability of 1 at node 19) to determine the probability of node 16 to be subtract from 1. This is an example of splitting probability of time by INHIBIT gates that then get combined by an OR. In this case the probability at node 16 is so small that a probability of 1 could have been used at node 19 without significant loss of accuracy on the overall tree calculation. Although the portion of time that the pressure gauge is not functional is small, this condition can add a significant probability that the rupture disk functionality will be compromised. The key impact of latency is in the calculation of the probability of the failed state for the event. Similar to exposure time, the event may occur anywhere within the interval between inspections. The exact time of failure is unknown, however using the exponential function for the assumption of random failures, the most likely time of failure can be calculated. The probability of failed state is then assumed to occur from that point forward. This is called the fractional downtime calculation. The function used to determine this probability is dependent on the fail rate, 1/mttf and inspection interval T as follows: \\[1-\\frac{1}{\\frac{1}{MTTF}*T}\\times(1-e^{-\\frac{1}{MTTF}*T)})\\] In some systems the time required to repair or restore the failure after detection must still be accounted for as unavailable time. In other cases, there is a lingering probability that the component will still be failed after restoration. These, often small, probability values are additive to the latency probability calculation. The addLatent function has a pzero argument for assignment of this additional probability. 6.1 Using the R Environment to Alter Inspection Intervals The resulting calculations suggest the undesired event may be expected to occur once in about 180 years. This might sound quite remote, but considering the hazards to personnel it is likely to be found unacceptable in most studies. It is possible to alter the inspection intervals and view several fault trees to see how changes to inspection scheduling could impact the frequency of the undesired event. However, it is somewhat cumbersome to go through all those motions just to view one number at the top. Since this model is built within the R environment it is possible to program several cases and report the final result, perhaps converted to MTTF rather than very small fail rates in scientific notation. This is something I doubt will be found available in most other GUI based fault tree software A set of test cases is constructed by combining vectors of each test parameter into a single matrix: rv_test&lt;-c(3,3,3,2,1,2,1) pi_test&lt;-c(3,1,1/12,1/12,1/12,1/52,1/52) walkby&lt;-c(3,1/12,1/52,1/52,1/52,1/52,1/52) cases&lt;-cbind(rv_test,pi_test,walkby) This matrix can be viewed by just re-typing its name in the R Console: cases ## rv_test pi_test walkby ## [1,] 3 3.00000000 3.00000000 ## [2,] 3 1.00000000 0.08333333 ## [3,] 3 0.08333333 0.01923077 ## [4,] 2 0.08333333 0.01923077 ## [5,] 1 0.08333333 0.01923077 ## [6,] 2 0.01923077 0.01923077 ## [7,] 1 0.01923077 0.01923077 Here the original example is represented by the values in case 2. Case 1 will represent the effect of not conducting the pi_test or walkby any more frequently than the rv_test. A series of more frequent testing is sampled to get an idea of each effect. Any number of cases could be modeled in this way. With the cases matrix defined in the current R session it is possible to program a loop to build an mttf column summarizing the results of calculated fault trees for each case. Since the probability at node 16 will be altered during various runs through the loop, unless we can alter the probability at node 18 programmatically a small inaccuracy may be entered. This is possible to accomplish in this fault tree since the latent probability of failure is calculated upon execution of the addLatent function. This code looks up this value for the proper subtraction to make the probability at node 18 complimentary to node 16 on each pass of fault tree construction. mttf&lt;-NULL CFRat14&lt;-NULL for(case in 1:dim(cases)[1]) { rv_test&lt;-cases[case,1] pi_test&lt;-cases[case,2] walkby&lt;-cases[case,3] hf&lt;-ftree.make(type=&quot;or&quot;, name=&quot;HF Vaporizer&quot;, name2=&quot;Rupture&quot;) hf&lt;-addLogic(hf, at=1, type=&quot;inhibit&quot;, name=&quot;Overpressure&quot;, name2=&quot;Unrelieved&quot;) hf&lt;-addDemand(hf, at=1, mttf=1e6, name= &quot;Vaporizer Rupture&quot;, name2=&quot;Due to Stress/Fatigue&quot;) hf&lt;-addLogic(hf, at=2, type=&quot;or&quot;, name=&quot;Pressure Relief System&quot;, name2=&quot;in Failed State&quot;) hf&lt;-addLogic(hf, at=2, type=&quot;or&quot;, name=&quot;Overpressure&quot;, name2=&quot;Occurs&quot;) hf&lt;-addLogic(hf, at=4, type=&quot;or&quot;, name=&quot;Pressure Relief&quot;, name2=&quot;Isolated&quot;) hf&lt;-addLatent(hf, at=6, mttf=10, pzero=0, inspect=walkby, name=&quot;Valve 20&quot;, name2=&quot;Left Closed&quot;) hf&lt;-addLatent(hf, at=6, mttf=10, pzero=0, inspect=walkby, display_under=7, name=&quot;Valve 21&quot;, name2=&quot;Left Closed&quot;) hf&lt;-addLogic(hf, at=4, type=&quot;or&quot;, name=&quot;Rupture Disk Fails&quot;, name2=&quot;to Open at Design Pt.&quot;) hf&lt;-addLogic(hf, at=9, type=&quot;or&quot;, name=&quot;Installation/Mfr&quot;, name2=&quot;Errors&quot;) hf&lt;-addProbability(hf, at=10, prob=.001, name=&quot;Rupture Disk&quot;, name2=&quot;Installed Upside Down&quot;) hf&lt;-addProbability(hf, at=10, prob=.001, display_under=11, name=&quot;Wrong Rupture Disk&quot;, name2=&quot;Installed&quot;) hf&lt;-addProbability(hf, at=10, prob=.001, display_under=12, name=&quot;Rupture Disk&quot;, name2=&quot;Manuf. Error&quot;) hf&lt;-addLogic(hf, at=9, type=&quot;or&quot;, name=&quot;Pressure Between Disk&quot;, name2=&quot;and Relief Valve&quot;) hf&lt;-addLogic(hf, at=14, type=&quot;inhibit&quot;, name=&quot;Pressure NOT&quot; , name2=&quot;Detectable by PI&quot;) hf&lt;-addLatent(hf, at=15, mttf=10, pzero=0, inspect=pi_test, name=&quot;Pressure Gage&quot;, name2=&quot;Failed Low Position&quot;) hf&lt;-addLatent(hf, at=15, mttf=10, pzero=0, inspect=pi_test, name=&quot;Rupture Disk Leak&quot;, name2=&quot;Undetected&quot;) hf&lt;-addLogic(hf, at=14, type=&quot;inhibit&quot;, name=&quot;Pressure&quot; , name2=&quot;Detectable by PI&quot;) hf&lt;-addProbability(hf, at=18, prob=(1-hf$PBF[16]), name=&quot;Pressure Gage&quot;, name2=&quot;Detects Pressure&quot;) hf&lt;-addLatent(hf, at=18, mttf=10, pzero=0, inspect=walkby, name=&quot;Rupture Disk Leak&quot;, name2=&quot;Detectable&quot;) hf&lt;-addLogic(hf, at=4, type=&quot;or&quot;, name=&quot;Pressure Relief Fails&quot;, name2=&quot; to Open at Design Pt&quot;) hf&lt;-addLatent(hf, at=21, mttf=300, pzero=0, inspect=rv_test, name=&quot;Pressure Relief&quot;, name2=&quot;set too high&quot;) hf&lt;-addLatent(hf, at=21, mttf=300, pzero=0, inspect=rv_test, name=&quot;Pressure Relief Unable&quot;, name2=&quot;to Open at Design Pt&quot;) hf&lt;-addDemand(hf, at=5, mttf=10, name= &quot;High Pressure&quot;, name2=&quot;Feed to Vaporizer&quot;) hf&lt;-addDemand(hf, at=5, mttf=10, name= &quot;Vaporizer Heating&quot;, name2=&quot;Runaway&quot;) hf&lt;-ftree.calc(hf) mttf&lt;-c(mttf,1/ hf$CFR[1]) CFRat14&lt;-c(CFRat14, hf$CFR[14]) } cases&lt;-cbind(cases, mttf, CFRat14) In order to verify that the complimentary probability has been appropriately applied at node19 a column of fail rates derived at node 14 is also prepared. This check column should always contain the basic fail rate provided for the rupture disk leak if probabilities at nodes 16 and 18 are indeed complimentary. After one or two blinks of an eye, re-typing the cases matrix name in the R Console reveals the tabularized results: cases ## rv_test pi_test walkby mttf CFRat14 ## [1,] 3 3.00000000 3.00000000 13.81637 0.1 ## [2,] 3 1.00000000 0.08333333 183.47023 0.1 ## [3,] 3 0.08333333 0.01923077 317.05770 0.1 ## [4,] 2 0.08333333 0.01923077 400.37429 0.1 ## [5,] 1 0.08333333 0.01923077 543.84168 0.1 ## [6,] 2 0.01923077 0.01923077 400.79484 0.1 ## [7,] 1 0.01923077 0.01923077 544.62051 0.1 As expected, the risk of the undesired event can be impacted by judicious testing, inspection and remediation. By fault tree modeling with an understanding of latency it is possible to define an appropriate inspection protocol. It is left as a student exercise to consider daily walkby inspections. What inspections could be considered for the rupture disk human error and manufacturing risks? Could replacement of the disk with a new one change these risks? "],
["conditional-sequence.html", "Chapter 7 Conditional Sequence", " Chapter 7 Conditional Sequence Thus far examples have demonstrated the use of OR, AND and INHIBIT gates. In the non-repairable model there is no difference between the AND and INHIBIT calculations. Both combine feeding probabilities by multiplication. The only difference is that the INHIBIT clarifies which feed is considered a condition. Now with the repairable model it can be observed that the INHIBIT essentially strips the conditional feed of all information but its probability parameter representing percent of time. As such the INHIBIT can model a sequential nature for certain conditions, typically protective, followed by a catastrophic hazard event. Yet, in some combinations the possible reversibility of the condition is an important consideration. The PRIORITY gate (referenced often as Priority AND) provides a conditional sequence logic appropriately handling a wider variety of combinations than the INHIBIT. Consider the independent failure of active pumps similar to those modeled as the Repairable System Model was introduced. actAND&lt;-ftree.make(type=&quot;and&quot;, name=&quot;Independent Failure&quot;, name2=&quot;of Active Pumps&quot;) actAND&lt;-addActive(actAND, at=1, mttf=3, mttr=12/8760, name=&quot;Pump 1&quot;) actAND&lt;-addActive(actAND, at=1, mttf=3, mttr=12/8760, name=&quot;Pump 2&quot;) actAND&lt;-ftree.calc(actAND) actAND[1,6:8] ## CFR PBF CRT ## 1 0.0003041362 2.083125e-07 0.0006849315 The selected range output reveals the quantification of just the top event. Then a line is added to display the repair time for the conditional event with a conversion from years to hours. actAND ## ID GParent CParent Level Type CFR PBF CRT MOE ## 1 1 -1 -1 1 11 0.0003041362 2.083125e-07 0.0006849315 0 ## 2 2 1 1 2 1 0.3333333333 4.564126e-04 0.0013698630 0 ## 3 3 1 1 2 1 0.3333333333 4.564126e-04 0.0013698630 0 ## PHF_PZ Condition Cond_Code Interval Tag_Obj Name ## 1 -1 0 0 -1 Independent Failure ## 2 -1 0 0 -1 Pump 1 ## 3 -1 0 0 -1 Pump 2 ## Name2 Description Unused1 Unused2 ## 1 of Active Pumps ## 2 ## 3 From this simple model it is observed that the repair time for dual pump failure is half the mttr input for single pump recovery. This is the mean of a saw-toothed distribution generated by a convolution of the pump downtime events. A second pump fails randomly within the 12 hour repair time of an initial pump failure. The event ends when the first pump to fail is repaired. It can be thought of that statistically the second pump fails mid-way into the failure of the first. Now a tree if formed by placing the same pumps under an INHIBIT gate. actPRIORITY&lt;-ftree.make(type=&quot;priority&quot;, reversible_cond=TRUE, name=&quot;Conditional Sequence&quot;, name2=&quot;of Repairable Pumps&quot;) actPRIORITY&lt;-addActive(actPRIORITY, at=1, mttf=3, mttr=12/8760, name=&quot;Pump 1&quot;) actPRIORITY&lt;-addActive(actPRIORITY, at=1, mttf=3, mttr=12/8760, name=&quot;Pump 2&quot;) actPRIORITY&lt;-ftree.calc(actPRIORITY) actPRIORITY [1,6:8] ## CFR PBF CRT ## 1 0.0001521375 1.042038e-07 0.0006849315 A physical analogy to this calculation would be a primary Pump 1 with a secondary stand-by backup Pump 2. Dual pump failure only occurs when the backup pump fails within the repair window of the primary. However, the event ends upon repair of the primary pump. Presumably then Pump 2 is returned to stand-by service once repaired. The distinction in the gate is made possible due to information on the repair time for the event presented as a condition. Again there is a convolution of the pump downtime events. However, dual pump failure requires a specific sequence beginning with failure of the primary pump. Systems with latency are more likely to generate conditions for propagation of unwanted events since the hidden nature of latent faults awaits compounding with some hazard event. When a condition is not effectively reversible once encountering a critical hazard the PRIORITY calculation is similar to the INHIBIT . Consider a fictitious pressurized system with pressure controlled feed and pressure controlled venting as the only protection against overpressure. The following table summarizes the input parameters: For the next FaultTree model scripts the magrittr (mag-rit-tay) package will be used. Since this is an established package on the CRAN repository installation is rather straight forward. I would usually close any open R consoles in order to avoid any confusion. Then open one, as administrator, to execute menu selections Packages -&gt; Install package(s). . . select the first mirror, then scroll down to magrittr. As with any package to use it in a session the library must be loaded. So, commands for library(magrittr) as well as library(FaultTree) will be required in any new R session. The magrittr package provides a short hand notation for passing the developing FaultTree object to successive script lines. The example code demonstrates this use. Note the definition of a new %&gt;% operator permits successive representation of the object as a dot for the first argument in the function call following the %&gt;% operator. A simple fault tree is now generated for Surge Tank Overpressure Failure. library(FaultTree) library(magrittr) surgePRIORITY&lt;-ftree.make(type=&quot;priority&quot;, name=&quot;Surge Tank&quot;, name2=&quot;Overpressure Failure&quot;) surgePRIORITY&lt;-surgePRIORITY %&gt;% addLogic(., at=1, type=&quot;or&quot;, name=&quot;Vent Control&quot;, name2=&quot;Fails Closed&quot;) %&gt;% addLogic(., at=1, type=&quot;or&quot;, name=&quot;Supply Control&quot;, name2=&quot;Fails Open&quot;) %&gt;% addLatent(., at=2, mttf=25, mttr=8/8760, pzero=&quot;repair&quot;, inspect=1, name=&quot;PV2&quot;, name2=&quot;Fails Closed&quot;) %&gt;% addLatent(., at=2, mttf=100, mttr=8/8760, pzero=&quot;repair&quot;, inspect=1, name=&quot;PC2 Forces&quot;, name2=&quot;PV2 Closed&quot;) %&gt;% addLatent(., at=2, mttf=100, mttr=8/8760, pzero=&quot;repair&quot;, inspect=1, name=&quot;PT2&quot;, name2=&quot;Fails Low&quot;) %&gt;% addActive(., at=3, mttf=25, mttr=8/8760, name=&quot;PV1&quot;, name2=&quot;Fails Open&quot;) %&gt;% addActive (., at=3, mttf=100, mttr=8/8760, name=&quot;PC1 Forces&quot;, name2=&quot;PV1 Open&quot;) %&gt;% addActive (., at=3, mttf=100, mttr=8/8760, name=&quot;PT1&quot;, name2=&quot;Fails Low&quot;) %&gt;% ftree.calc(.) ftree2html(surgePRIORITY, write_file=TRUE) ## ID Parent Type CFR PBF CRT Cond ## 1 1 -1 14 0.001772091 -1.000000e+00 -1.0000000000 0 ## 2 2 1 10 -1.000000000 2.953486e-02 -1.0000000000 1 ## 3 3 1 10 0.060000000 5.479227e-05 0.0009132545 0 ## 4 4 2 2 0.040000000 1.977179e-02 0.0009132420 0 ## 5 5 2 2 0.010000000 4.992462e-03 0.0009132420 0 ## 6 6 2 2 0.010000000 4.992462e-03 0.0009132420 0 ## 7 7 3 1 0.040000000 3.652835e-05 0.0009132420 0 ## 8 8 3 1 0.010000000 9.132337e-06 0.0009132420 0 ## 9 9 3 1 0.010000000 9.132337e-06 0.0009132420 0 ## Name Name2 ## 1 Surge Tank Overpressure Failure ## 2 Vent Control Fails Closed ## 3 Supply Control Fails Open ## 4 PV2 Fails Closed ## 5 PC2 Forces PV2 Closed ## 6 PT2 Fails Low ## 7 PV1 Fails Open ## 8 PC1 Forces PV1 Open ## 9 PT1 Fails Low browseURL(&quot;surgePRIORITY.html&quot;) This script has rendered poorly in the code block, but it should copy and paste successfully. It is now expected that either text files as discussed in Fault Tree Basics or spreadsheet as discussed in the (pending) Appendix are being used by the reader to hold these developing scripts. Now the same tree can be re-created using an inhibit gate for the top event. Only the first two lines of the script ( after the library calls) need to be changed since the magrittr pipeline is used. The browseURL function cannot utilize the pipeline, so a graphical view has to be generated separately. The four lines of code to include in the new script are: surgeINHIBIT&lt;-ftree.make(type=&quot;inhibit&quot;, name=&quot;Surge Tank&quot;, name2=&quot;Overpressure Failure&quot;) # surgeINHIBIT&lt;-surgeINHIBIT %&gt;% ftree2html(surgeINHIBIT, write_file=TRUE) browseURL(&quot;surgeINHIBIT.html&quot;) Since the point of interest here is the difference between the two top gates a photoshoped image of these two collapsed trees is presented in one frame. Both top gates receive the same information from the feeding OR gates. The condition only passes a probability value. In the case of the PRIORITY gate this is because the default of reversible_cond = FALSE has been set. If the result of vent failure leads to vessel rupture, it makes no sense to pass on vent system repair information. Further, this irreversible PRIORITY gate has resolved its resulting event to be a pure demand with an output containing a fail rate result only. The INHIBIT gate simply applies the conditional percent of time on both Fail Rate and Probability of the combining event. All inhibited information from the combined event is passed upward even if it is irrelevant for the model under consideration. However, there is no difference in the final Fail Rate calculated output. To make this example more realistic, and ASME code compliant, a pressure relief valve is added to the surge tank. This adds a valuable redundancy to over-pressure relief venting as expected. It also renders the failure condition of the vent controller to be reversible. surge3&lt;-ftree.make(type=&quot;priority&quot;, name=&quot;Surge Tank&quot;, name2=&quot;Overpressure Failure&quot;) surge3&lt;-surge3 %&gt;% addLogic(., at=1, type=&quot;or&quot;, name=&quot;Pressure Relief Fails&quot;, name2=&quot;to Open at Design Pt&quot;) %&gt;% addLatent (., at=2, mttf=300, pzero=0, inspect=3, name=&quot;Pressure Relief&quot;, name2=&quot;set too high&quot;) %&gt;% addLatent(., at=2, mttf=300, pzero=0, inspect=3, name=&quot;Pressure Relief Unable&quot;, name2=&quot;to Open at Design Pt&quot;) %&gt;% addLogic(., at=1, type=&quot;priority&quot;, reversible_cond=TRUE, name=&quot;Vent Control Failed&quot;, name2=&quot;On Overpressure&quot;) %&gt;% addLogic(., at=5, type=&quot;or&quot;, name=&quot;Vent Control&quot;, name2=&quot;Fails Closed&quot;) %&gt;% addLogic(., at=5, type=&quot;or&quot;, name=&quot;Supply Control&quot;, name2=&quot;Fails Open&quot;) %&gt;% addLatent(., at=6, mttf=25, mttr=8/8760, pzero=&quot;repair&quot;, inspect=1, name=&quot;PV2&quot;, name2=&quot;Fails Closed&quot;) %&gt;% addLatent(., at=6, mttf=100, mttr=8/8760, pzero=&quot;repair&quot;, inspect=1, name=&quot;PC2 Forces&quot;, name2=&quot;PV2 Closed&quot;) %&gt;% addLatent(., at=6, mttf=100, mttr=8/8760, pzero=&quot;repair&quot;, inspect=1, name=&quot;PT2&quot;, name2=&quot;Fails Low&quot;) %&gt;% addActive(., at=7, mttf=25, mttr=8/8760, name=&quot;PV1&quot;, name2=&quot;Fails Open&quot;) %&gt;% addActive (., at=7, mttf=100, mttr=8/8760, name=&quot;PC1 Forces&quot;, name2=&quot;PV1 Open&quot;) %&gt;% addActive (., at=7, mttf=100, mttr=8/8760, name=&quot;PT1&quot;, name2=&quot;Fails Low&quot;) %&gt;% ftree.calc(.) ftree2html(surge3, write_file=TRUE) ## ID Parent Type CFR PBF CRT Cond ## 1 1 -1 14 1.761798e-05 -1.000000e+00 -1.0000000000 0 ## 2 2 1 10 -1.000000e+00 9.941916e-03 -1.0000000000 1 ## 3 3 2 2 3.333333e-03 4.983375e-03 -1.0000000000 0 ## 4 4 2 2 3.333333e-03 4.983375e-03 -1.0000000000 0 ## 5 5 1 14 1.772091e-03 1.618368e-06 0.0009132545 0 ## 6 6 5 10 -1.000000e+00 2.953486e-02 0.0009132545 1 ## 7 7 5 10 6.000000e-02 5.479227e-05 0.0009132545 0 ## 8 8 6 2 4.000000e-02 1.977179e-02 0.0009132420 0 ## 9 9 6 2 1.000000e-02 4.992462e-03 0.0009132420 0 ## 10 10 6 2 1.000000e-02 4.992462e-03 0.0009132420 0 ## 11 11 7 1 4.000000e-02 3.652835e-05 0.0009132420 0 ## 12 12 7 1 1.000000e-02 9.132337e-06 0.0009132420 0 ## 13 13 7 1 1.000000e-02 9.132337e-06 0.0009132420 0 ## Name Name2 ## 1 Surge Tank Overpressure Failure ## 2 Pressure Relief Fails to Open at Design Pt ## 3 Pressure Relief set too high ## 4 Pressure Relief Unable to Open at Design Pt ## 5 Vent Control Failed On Overpressure ## 6 Vent Control Fails Closed ## 7 Supply Control Fails Open ## 8 PV2 Fails Closed ## 9 PC2 Forces PV2 Closed ## 10 PT2 Fails Low ## 11 PV1 Fails Open ## 12 PC1 Forces PV1 Open ## 13 PT1 Fails Low browseURL(&quot;surge3.html&quot;) Although the reversibility of the vent controller failed state does not affect the quantification in this example, the repair information from this condition is now passed upward from gate 6. The graphic displays the repair rate information for the condition in darker font to provide a verification that the condition has been considered reversible. The fact that a failed condition for pressure relief valve is not reversible has precluded further use of the vent controller reversibility information in the top event of this example. "]
]
